package org.frc5587.lib.subsystems;

import org.frc5587.lib.controllers.ArmFPIDController;
import org.frc5587.lib.pid.FPID;
import edu.wpi.first.wpilibj.SpeedControllerGroup;
import edu.wpi.first.wpilibj.controller.ArmFeedforward;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj2.command.PIDSubsystem;
import edu.wpi.first.wpilibj.DigitalInput;
import edu.wpi.first.wpilibj.SpeedController;

public abstract class FPIDSubsystemBase extends PIDSubsystem {
    protected FPIDConstants constants;
    // the leader motor is defined as its own variable, while followers are put into an array for easy use.
    protected SpeedController leader;
    protected SpeedController[] followers;
    protected SpeedControllerGroup motorGroup;

    private DigitalInput limitSwitch;
    private ArmFPIDController controller;

    // what type of value we can get from an encoder
    public static enum EncoderValueType {
        Velocity, Position
    }

    public static class FPIDConstants {
        public double speedMultiplier;
        public int limitSwitchPort;
        public FPID fpid;
        public ArmFeedforward ff;

        public ArmsConstants(double speedMultiplier, int limitSwitchPort, FPID fpid, ArmFeedforward ff) {
            this.speedMultiplier = speedMultiplier;
            this.limitSwitchPort = limitSwitchPort;
            this.fpid = fpid;
            this.ff = ff;
        }
    }

    // pass motors as an array of SpeedControllers, eg. WPI_TalonFX[] or CANSparkMax[]
    public FPIDSubsystemBase(FPIDConstants constants, SpeedController[] motors) {
        super(new ArmFPIDController(constants.fpid.kF, constants.fpid.kP, constants.fpid.kI, constants.fpid.kD, constants.ff));
        // set the controller variable to the ArmFPIDController we just made above
        controller = (ArmFPIDController) getController();
        //disable PID control when starting
        this.disable();

        /* THE BELOW LINES WILL BE USED AFTER CHARACTERIZATION. DO NOT USE THEM NOW */

        // this.enable();
        // controller.enableFeedForward();

        this.constants = constants;
        limitSwitch = new DigitalInput(constants.limitSwitchPort);

        motorGroup = new SpeedControllerGroup(motors);

        configureMotors();
    }

    // have the implementing class configure the motors
    public abstract void configureMotors();

    // the implementing class also needs to get and set encoder values
    // param type: what type of value we're getting from the encoder. values Position and Velocity as defined above in EncoderValueType
    public abstract double getEncoderValue(EncoderValueType type);

    public abstract void setEncoderPosition(double position);

    public ArmFPIDController getFPIDController() {
        return controller;
    }

    // move the mechanism based on a given throttle 
    public void moveByThrottle(double throttle) {
        motorGroup.set(-throttle * constants.speedMultiplier); // negative throttle is on purpose!
    }

    // move the mechanism based on a constant multiplier (for operation with buttons)
    public void moveByFixedSpeed(boolean inverted) {
        motorGroup.set((inverted ? -1 : 1) * constants.speedMultiplier);
    }

    // moves the mechanism based on voltage instead of speed
    public void moveByVolts(double voltage, boolean inverted) {
        motorGroup.setVoltage((inverted ? -1 : 1) * voltage);
    }

    // calculates the feedForward for the PIDController
    public double calcFeedForward() {
        // double ff = constants.ff.calculate(Math.toRadians(SmartDashboard.getNumber("Goto Position", 0)), 0) / 12;
        return controller.calculateF(Math.toRadians(SmartDashboard.getNumber("Goto Position", 0)), 0);
    }

    public void startPID() {
        SmartDashboard.putNumber("Goto Position", 0);
    }

    // displays various PID values on SmartDashboard
    public void refreshPID() {
        SmartDashboard.putNumber("Angle", getPositionDegrees());
        SmartDashboard.putNumber("Encoder Val", getPositionRotation());
        SmartDashboard.putNumber("FF", calcFeedForward());
    }
    
    // gets the encoder's position
    public double getPositionRotation() {
        return getEncoderValue(EncoderValueType.Position);
    }

    public double getPositionDegrees() {
        return getPositionRotation() / 180;
    }

    public DigitalInput getLimitSwitch() {
        return limitSwitch;
    }

    public boolean getLimitSwitchValue() {
        return !(limitSwitch.get());
    }
    
    // uses PID output to move the mechanism
    @Override
    protected void useOutput(double output, double setpoint) {
        try {
            moveByThrottle(output);
        }
        catch(NullPointerException e) {
            System.out.println("NullPointerException " + e + " from useOutput. \n A constant was likely not given by DriveConstants object");
        }
    }

    @Override
    public void disable() {
        this.m_enabled = false;
        motorGroup.set(0);
    }

    @Override
    protected double getMeasurement() {
        return getEncoderValue(EncoderValueType.Position);
    }

    @Override
    public void periodic() {
        System.out.println(getPositionDegrees());
        refreshPID();
        controller.setF(calcFeedForward());
        // double setpoint = constants.ff.calculate(Math.toRadians(getPositionDegrees()), getEncoderValue(EncoderValueType.Velocity));
        // double output = controller.calculate(getMeasurement(), setpoint, getEncoderValue(EncoderValueType.Velocity));
        // useOutput(output, setpoint);
    }

    // sets encoders back to 0
    public void resetEncoders() {
        setEncoderPosition(0);
    }

    // stops the speedcontroller group
    public void stop() {
        motorGroup.set(0);
    }

    // stops every motor without going through the speedcontroller group
    public void stopMotors() {
        leader.set(0);
        for(SpeedController follower : followers) {
            follower.set(0);
        }
    }
}
